from __future__ import absolute_import, division, print_function, unicode_literals
import pandas as pd
import seaborn as sns
from math import floor, ceil
from pylab import rcParams
from sklearn.model_selection import train_test_split
# TensorFlow and tf.keras
import tensorflow as tf
from tensorflow import keras
import matplotlib.pyplot as plt
import numpy as np
from sklearn.utils import class_weight
import pandas
from keras.models import Sequential
from keras.layers import Dense, Flatten, Dropout
from keras.wrappers.scikit_learn import KerasClassifier
from keras.utils import np_utils
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import KFold
from sklearn.preprocessing import LabelEncoder
from sklearn.pipeline import Pipeline
from tensorflow.keras.callbacks import TensorBoard
NAME = "Cats-vs-dogs-CNN"
tensorboard = TensorBoard(log_dir="logs\{}".format(NAME))

order = 3  # this is an order of approximation, which is not relevant at the moment
modes = 15 # (or 21) the number of modes
mode_val=[]
pump_poww=[]
for w0 in np.arange(570.0,600.5,0.25):
#wav0 = 585.0 # the cutoff-frequency of the cavity which decides the thermalisation
    alldata=np.load(r"C:\Users\roryp\OneDrive\Documents\Yr3project\Data_v2"+"\\threshData_{}_{}_{}.npy".format(w0,modes,order),encoding='bytes',allow_pickle=True).item(0)
    mode_val.append(list(alldata.values())[1])
    pump_poww.append(list(alldata.values())[0])
training_w0=[]
training_pump=[]

for i in range(122):
    if len(mode_val[i]) == 129:
        for j in range(129):
            training_w0.append(np.arange(570.0,600.5,0.25)[i])
            training_pump.append(pump_poww[i][j])
print(mode_val[100][100])


threshold=1e4
y=[]
# Find output for 40 w and 33 pump_pow
for w0 in range(122):
    w=[]
    for pump_power in range(129):
        
        if len(mode_val[w0]) == 129:
            populated_modes=[0 for i in range(len(mode_val[w0][pump_power]))]
            for mode in range(len(mode_val[w0][pump_power])):
                threshold1=(max(mode_val[w0][pump_power])+min(mode_val[w0][pump_power]))/2
                if mode_val[w0][pump_power][mode]>=threshold:# and mode_val[w0][pump_power][mode]>=threshold1:
                    
                    populated_modes[mode]=1
    
    
            y.append(populated_modes)
            
    #y.append(w)
for j in range(len(y)):
    if y[j][0]==0:
        print(y[j])



#training_pump=np.ravel(pump_poww)
#print(training_pump[0])

x=[]
x.append(training_w0)
x.append(training_pump)
#x.append(y)
x=pd.DataFrame(data=x)

X=x.T
#print((X))
X=pd.DataFrame.to_numpy(X)
y=pd.DataFrame(y)
y=pd.DataFrame.to_numpy(y)
print(y)


X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
#print(y_train.count(0),y_train.count(1))
plt.plot(y_test, color = 'red', label = 'Real data')


# demonstrate data normalization with sklearn
from sklearn.preprocessing import MinMaxScaler
sc = MinMaxScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)
print(y_train)


model = Sequential()
#model.add(Flatten(input_shape=(2,)))
model.add(Dense(30, input_dim=2, activation='relu'))
#model.add(Dropout(0.1))
model.add(Dense(49, activation='relu'))
model.add(Dense(49, activation='relu'))
model.add(Dense(49, activation='relu'))
#model.add(Dropout(0.1))
model.add(Dense(15, activation='sigmoid'))

sgd = keras.optimizers.SGD(lr=0.01, decay=1e-6, momentum=0.9, nesterov=True)
model.compile(loss='binary_crossentropy',
              optimizer='adam')

model.fit(X_train, y_train, epochs=10, batch_size=10)

preds = model.predict(X_test)
preds[preds>=0.5] = 1
preds[preds<0.5] = 0


def convert(list): 
      
    # Converting integer list to string list 
    s = [str(int(i)) for i in list] 
      
    # Join list items using join() 
    res = int("".join(s)) 
    #print(type(res))
    return(int(str(res),2)) 
print(preds[130])
convert(preds[130]) 

yy=[]
for i in range(len(preds)):
    yy.append(convert(preds[i]))
#print(yy)
y_test1=[]
for i in range(len(y_test)):
    y_test1.append(convert(y_test[i]))
print(bin(15840)[2:].zfill(15))


#%%
y_pred = model.predict(X_test)
correct=[]
wrong=[]
for i in range(len(preds)):
    for j in range(15):
        if preds[i][j]==y_test[i][j]:
            correct.append(1)
        else:
            wrong.append(1)
print(1-len(correct)/(len(preds)*len(preds[0])))            

#%%
p_p=X_test[:,1]
w0_s=[]
for i in range(len(X_test[:,0])):
    w0_s.append(X_test[:,0][i]*(600.25-500)+500)
w0_s=np.array(w0_s)


laserw=[]
laserp=[]
laserz=[]
randw=[]
randp=[]
randz=[]
rand1w=[]
rand1p=[]
rand1z=[]
rand2w=[]
rand2p=[]
rand2z=[]
rand3w=[]
rand3p=[]
rand3z=[]
rand4w=[]
rand4p=[]
rand4z=[]
rand5w=[]
rand5p=[]
rand5z=[]
rand6w=[]
rand6p=[]
rand6z=[]
rand7w=[]
rand7p=[]
rand7z=[]
rand8w=[]
rand8p=[]
rand8z=[]
becw=[]
becp=[]
becz=[]
otherw=[]
otherp=[]
otherz=[]
print(sc.inverse_transform(X_train))
yy=[]
for i in range(len(preds)):
    yy.append(convert(preds[i]))
#yy=y_test1
for i in range(len(yy)):
    if yy[i] in [16384]:
        becw.append(w0_s[i])
        becp.append(p_p[i])
        becz.append(0)
    if yy[i]==16768:# y_test1[i] in [32248, 32256, 32640, 32704, 32736, 32744, 32760, 32761, 32767]:
        rand1w.append(w0_s[i])
        rand1p.append(p_p[i])
        rand1z.append(3)
    if yy[i]==31744:# y_test1[i] in [32248, 32256, 32640, 32704, 32736, 32744, 32760, 32761, 32767]:
        randw.append(w0_s[i])
        randp.append(p_p[i])
        randz.append(2)
    if yy[i]==28672:# y_test1[i] in [32248, 32256, 32640, 32704, 32736, 32744, 32760, 32761, 32767]:
        rand2w.append(w0_s[i])
        rand2p.append(p_p[i])
        rand2z.append(4)
    if yy[i]==15864:# y_test1[i] in [32248, 32256, 32640, 32704, 32736, 32744, 32760, 32761, 32767]:
        rand3w.append(w0_s[i])
        rand3p.append(p_p[i])
        rand3z.append(3)
    if yy[i]==3968:# y_test1[i] in [32248, 32256, 32640, 32704, 32736, 32744, 32760, 32761, 32767]:
        rand4w.append(w0_s[i])
        rand4p.append(p_p[i])
        rand4z.append(6)
    if yy[i]==19456:# y_test1[i] in [32248, 32256, 32640, 32704, 32736, 32744, 32760, 32761, 32767]:
        rand5w.append(w0_s[i])
        rand5p.append(p_p[i])
        rand5z.append(5)
    if yy[i]==29696:# y_test1[i] in [32248, 32256, 32640, 32704, 32736, 32744, 32760, 32761, 32767]:
        rand6w.append(w0_s[i])
        rand6p.append(p_p[i])
        rand6z.append(8)
    if yy[i]==12160:# y_test1[i] in [32248, 32256, 32640, 32704, 32736, 32744, 32760, 32761, 32767]:
        rand7w.append(w0_s[i])
        rand7p.append(p_p[i])
        rand7z.append(8)
    if yy[i]==12288:# y_test1[i] in [32248, 32256, 32640, 32704, 32736, 32744, 32760, 32761, 32767]:
        rand8w.append(w0_s[i])
        rand8p.append(p_p[i])
        rand8z.append(5)
    if yy[i]==0:# y_test1[i] in [32248, 32256, 32640, 32704, 32736, 32744, 32760, 32761, 32767]:
        laserw.append(w0_s[i])
        laserp.append(p_p[i])
        laserz.append(6)
    
    else:
        otherw.append(w0_s[i])
        otherp.append(p_p[i])
        otherz.append(1)
plt.figure()
plt.plot([1/laserw[i] for i in range(len(laserw))],laserp,'o',color='b')
plt.plot([1/otherw[i] for i in range(len(otherw))],otherp,'s',color='g')#,markersize=10)
plt.plot([1/becw[i] for i in range(len(becw))],becp,'s',color='r')#,markersize=10)
plt.plot([1/randw[i] for i in range(len(randw))],randp,'s',color='k')#,markersize=10)
plt.plot([1/rand1w[i] for i in range(len(rand1w))],rand1p,'s',color='y')#,markersize=10)
plt.plot([1/rand2w[i] for i in range(len(rand2w))],rand2p,'s',color='c')#,markersize=10)
plt.plot([1/rand3w[i] for i in range(len(rand3w))],rand3p,'o',color='#FF1493')
plt.plot([1/rand4w[i] for i in range(len(rand4w))],rand4p,'o',color='#FF1491')
plt.plot([1/rand5w[i] for i in range(len(rand5w))],rand5p,'s',color='#FF1593')#,markersize=10)
plt.plot([1/rand7w[i] for i in range(len(rand7w))],rand7p,'o',color='#FF9495')
plt.plot([1/rand8w[i] for i in range(len(rand8w))],rand8p,'+',color='#FF9495')

plt.yscale("log")
#plt.xscale("log")
plt.text(1.69e-3,0.001,'A',fontsize=15)
plt.text(1.78e-3,0.00001,'B',color='w',fontsize=15)
plt.text(1.82e-3,0.000001,'C',color='g',fontsize=15)
plt.ylabel(r"Pump rate $\Gamma{\uparrow}$",fontsize=15)
plt.text(1.87e-3,0.001,'D',fontsize=15)
plt.text(1.908e-3,0.01,'A',fontsize=15)
plt.xlabel(r"Thermalisation $\frac{1}{\lambda_{0}}$",fontsize=15)
plt.title("Discrete phase diagram for NN output",fontsize=15)
plt.ticklabel_format(style='sci', axis='x', scilimits=(0,0))
plt.tick_params(labelsize=15)
print(list(set(yy)))
for i in range(len(list(set(yy)))):
    print(bin(list(set(yy))[i])[2:].zfill(15))
