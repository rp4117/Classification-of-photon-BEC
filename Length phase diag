 	#Import Packages
from __future__ import absolute_import, division, print_function, unicode_literals
import pandas as pd
from sklearn.model_selection import train_test_split
from tensorflow import keras
import matplotlib.pyplot as plt
import numpy as np
import scipy.interpolate
from sklearn.preprocessing import MinMaxScaler

#Import Data (v2)
order = 3 # this is the order of approximation
modes = 15 # number of modes
mode_val=[]
pump_poww=[]

# Load data for each cut-off wavelength w0
for w0 in np.arange(570.0,600.5,0.25):
    mode_val.append(list(alldata.values())[1])
    pump_poww.append(list(alldata.values())[0])
training_w0=[]
training_pump=[]


for i in range(122):
    if len(mode_val[i]) == 129:
        for j in range(129):
            training_w0.append(np.arange(570.0,600.5,0.25)[i])
            training_pump.append(pump_poww[i][j])
print('number of training w0s',len(training_w0))

#Finding no of condensed modes for each combanation of p_p and w0.

threshold=1e4
y=[]
# Find output for 40 w and 33 pump_pow
for w0 in range(122):
    
    for pump_power in range(129):
        if len(mode_val[w0]) == 129:
            populated_modes=[]
            for mode in range(len(mode_val[w0][pump_power])):
                threshold1=(max(mode_val[w0][pump_power])+min(mode_val[w0][pump_power]))/2
                if mode_val[w0][pump_power][mode]>=threshold:# and mode_val[w0][pump_power][mode]>=threshold1:
                    
                    populated_modes.append(mode_val[w0][pump_power][mode])
            y.append(len(populated_modes))

#Scaling the lengths to be number of modes condensed/13, because the largest length in the data was 13.

print(max(y))

for i in range(len(y)):
    y[i]=(y[i]-min(y))/(max(y)-min(y))

#Formatting Data    
    
x=[]
x.append(training_w0)
x.append(training_pump)

x=pd.DataFrame(data=x)


X=x.T

X=pd.DataFrame.to_numpy(X)

print('Number of [Pump power,cut off freq]:',len(X))

#Splitting the Data into test/train

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.03, random_state=42)

#Plotting the test data

plt.figure()
plt.plot(y_test, color = 'red', label = 'Real data')
plt.title('Test data')
plt.show()
print('this',X_test[17])

#Normalising w0 and p_p

sc = MinMaxScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)
print(y_train)
y_train=np.array(y_train)

#Training the neural network using the train data.

model = keras.Sequential([
    keras.layers.Flatten(input_shape=(2,)),
    keras.layers.Dense(2, input_dim=2, activation='relu'),
	keras.layers.Dense(26,  activation='relu', kernel_initializer='uniform'),
    keras.layers.Dense(26,  activation='relu', kernel_initializer='uniform'),
    #keras.layers.Dense(26,  activation='relu', kernel_initializer='uniform'),

    #keras.layers.Dense(42,  activation='relu', kernel_initializer='uniform'),
    #keras.layers.Dense(42,  activation='relu', kernel_initializer='uniform'),
    #keras.layers.Dense(49,  activation='relu', kernel_initializer='uniform'),
    keras.layers.Dense(1,activation='sigmoid'),
])

sgd = keras.optimizers.SGD(lr=0.001)
model.compile(loss='mse', optimizer='adam',metrics=['mse'])

model.fit(X_train, y_train, epochs=10, batch_size=10)

#Testing the neural network

y_pred=model.predict(X_test)
print(y_pred)

#Denormalising the neural network test data and rounding it to the nearest integer.

y_pred = [round(y_pred[i][0]*13) for i in range(len(X_test))]
y_test = [round(y_test[i]*13) for i in range(len(X_test))]

#Plotting the data used to test the neural network, with that the neural network predicts.

plt.figure()
plt.plot(y_pred,color='k')
plt.plot(y_test,color='r')
plt.title('Comparing Error in prediction by neural network')
plt.legend(('Data predicted by Neural Network','Test Data'))
plt.grid()
plt.show()
print(y_test)

#Plotting a histogram of the instances of each length classification of the test data.

plt.figure()
plt.hist(y_test,bins=100,align='mid')
plt.xlabel("Number of condensed modes:")
plt.ylabel('Number of instances:')
plt.grid()
plt.show()

#Phase plot given by data

p_p=X_test[:,1]
w0_s=X_test[:,0]#np.array([X_test[:,0][i]*(600.25-570)+570 for i in range(len(X_test[:,0]))])

yy=y_test
print(y_test)

yy=np.array(yy)
y = p_p
x = np.array([w0_s[i]*(600.25-500)+500 for i in range(len(w0_s))]) 
z = yy

z=np.array(z)
nInterp = 200
xi, yi = np.linspace(x.min(), x.max(), nInterp), np.linspace(y.min(), y.max(), nInterp)
xi, yi = np.meshgrid(xi, yi)

zi = scipy.interpolate.griddata((x, y), z, (xi, yi), method='linear')
plt.figure()
plt.imshow(zi, vmin=z.min(), vmax=z.max(), origin='lower',
       extent=[x.min(), x.max(), y.min(), y.max()], aspect='auto') 

plt.xlabel(r"$\omega_{0}$")

plt.ylabel(r"$\Gamma_{\uparrow}$",rotation=0)
plt.title(r"Variation of output error with $\Gamma_{\uparrow}$ and $\omega_{0}$")
#plt.yscale("log")
cb=plt.colorbar()
cb.set_label("# condensed modes")
plt.show()

#Predicted phase plot by neural network

p_p=X_test[:,1]
w0_s=X_test[:,0]#np.array([X_test[:,0][i]*(600.25-570)+570 for i in range(len(X_test[:,0]))])#X_test[:,0]

y=y_pred

yy=np.array(y)

y = p_p
x = np.array([1/(w0_s[i]*(600.25-500)+500) for i in range(len(w0_s))]) 
#x=np.array(w0_s)
z = yy

z=np.array([int(z[i]) for i in range(len(z))])
print(z)
nInterp = 200
xi, yi = np.linspace(x.min(), x.max(), nInterp), np.linspace(y.min(), y.max(), nInterp)
xi, yi = np.meshgrid(xi, yi)

zi = scipy.interpolate.griddata((x, y), z, (xi, yi), method='linear')
plt.figure()
plt.imshow(zi, vmin=z.min(), vmax=z.max(), origin='lower',
       extent=[x.min(), x.max(), y.min(), y.max()], aspect='auto') 

plt.xlabel(r"$\gamma$")
plt.ylabel(r"$\Gamma_{\uparrow}$",rotation=0)
plt.yscale("log")
plt.title(r"Variation of $N^{o}$ condensed modes with $\Gamma_{\uparrow}$ and $\lambda_{0}$")
cb=plt.colorbar()
cb.set_label(r"$N^{o}$ condensed modes")
plt.show()
print(min(y_test))

#Difference in Predicted and Data phase plots
p_p=X_test[:,1]
w0_s=X_test[:,0]

yp=y_pred
yy=[]
for i in range(len(y)):
    yy.append((abs(yp[i]-y_test[i]))/15)

yy=np.array(yy)

y = p_p
x = np.array([1/(w0_s[i]*(600.25-500)+500) for i in range(len(w0_s))]) 
z = yy

nInterp = 200
xi, yi = np.linspace(x.min(), x.max(), nInterp), np.linspace(y.min(), y.max(), nInterp)
xi, yi = np.meshgrid(xi, yi)

zi = scipy.interpolate.griddata((x, y), z, (xi, yi), method='linear')
plt.figure()
plt.imshow(zi, vmin=z.min(), vmax=.4, origin='lower',
       extent=[x.min(), x.max(), y.min(), y.max()], aspect='auto') 

plt.xlabel(r"$\gamma$:")
plt.ylabel(r"$\Gamma_{\uparrow}$:",rotation=0)
plt.title(r"Variation of output error with $\Gamma_{\uparrow}$ and $\gamma$")
cb=plt.colorbar()
cb.set_label("Error")
plt.show()
print(y_pred)

